#!/usr/bin/python

import json
import os
import re
import subprocess
import sys

directoryToDoh     = {}
directories        = {}
fileToDirectories  = {}
symbolToObjectFile = {}
hFilePat           = re.compile(r'\s(\S+\.h): No such file')
symbolPat          = re.compile(r'[\da-f]+\s+\w\s+(\w+)$')

class Directory:
    def __init__(self, path):
        self.path         = path
        directories[path] = self

    @classmethod
    def fromPath(clazz, path):
        """
        Get or construct directory object for path
        """

        try:
            return directories[path]
        except KeyError:
            return clazz(path)

    def getRelpath(self, start=os.curdir):
        return os.path.relpath(self.path, start)

    def getContents(self):
        """
        Get contents of directory, caching them, and map include/import file names back to directories
        @return an ordered pair of lists of files and subdirectories
        """

        #print "getContents " + self.path
        try:
            return (self.files, self.subDirs)
        except AttributeError:
            self.files   = []
            self.subDirs = []

            for entry in os.listdir(self.path):
                entryPath = os.path.join(self.path, entry)
                #print entryPath
                if os.path.isdir(entryPath):
                    self.subDirs.append(entry)
                    continue

                if os.path.isfile(entryPath):
                    self.files.append(entry)

                    # Map files that we may need to search for (e.g. header files)

                    if entry.endswith(".h"):
                        if entry not in fileToDirectories:
                            fileToDirectories[entry] = [self]
                        else:
                            fileToDirectories[entry].append(self)

        return (self.files, self.subDirs)

def findFile(dirPath, fileName, exclude=None):
    """
    Look for the fileName in all directories under the dirPath, excluding the exclude subdirectory if set or parent if ".."
    """

    (files, subDirs) = Directory.fromPath(dirPath).getContents()
    #print "Looking for %s under %s (subDirs=%s)" % (fileName, dirPath, str(subDirs))

    # May be in this directory
    try:
        return fileToDirectories[fileName]
    except KeyError:
        pass

    # Otherwise, look in all subdirectories

    for subDir in subDirs:
        if subDir == exclude or subDir == ".git":
            continue

        findFile(os.path.join(dirPath, subDir), fileName, exclude="..")

    # Return if found
    try:
        return fileToDirectories[fileName]
    except KeyError:
        pass

    # If we came from the parent, return none
    if exclude == "..":
        return None

    parent = os.path.dirname(dirPath)

    # Don't leave the user's directory; may want to allow this to be overridden
    if parent == "/home":
        return None

    return findFile(parent, fileName, exclude=dirPath)

def sourceToTargetFileName(sourceFileName):
    return "target/" + sourceFileName[:-2] + ".o"

def compileSources(dirPath):
    """
    Compile all source files found in dirPath and any of its subdirectories
    """

    dohDirty = False
    dohFile  = os.path.join(dirPath, "baker.doh")

    if dirPath not in directoryToDoh:
        print dohFile
        if os.path.isfile(dohFile):
            with open(dohFile) as input:
                contents = input.read()

                try:
                    directoryToDoh[dirPath] = json.loads(contents)
                except ValueError:
                    sys.exit("%s: Can't understand contents of %s:\n'%s'" % (__file__, dohFile, contents))

        else:
            directoryToDoh[dirPath] = {}

    dirDoh  = directoryToDoh[dirPath]
    oldPath = os.getcwd()
    os.chdir(dirPath)
    (files, subDirs) = Directory.fromPath(dirPath).getContents()
    print "Compiling directory " + dirPath + " files " + str(files) + " subDirs " + str(subDirs)

    for subDir in subDirs:
        if subDir == ".git":
            continue

        compileSources(os.path.join(dirPath, subDir))

    for entry in files:
        if entry.endswith(".c"):
            if not os.path.isdir("target"):
                os.mkdir("target")

            entryIncludeDirsProp = entry + ".includeDirectories"
            extraIncludeDirs     = set(dirDoh[entryIncludeDirsProp] if entryIncludeDirsProp in dirDoh else [])

            while True:
                try:
                    ccCommand = ["cc", "-c", os.path.join(dirPath, entry), "-o", sourceToTargetFileName(entry)]

                    for incDirPath in list(extraIncludeDirs):
                        ccCommand.extend(["-I", incDirPath])

                    print "about to " + " ".join(ccCommand)
                    subprocess.check_output(ccCommand, stderr=subprocess.STDOUT)

                    if len(extraIncludeDirs) > (len(dirDoh[entryIncludeDirsProp]) if entryIncludeDirsProp in dirDoh else 0):
                        dirDoh[entryIncludeDirsProp] = list(extraIncludeDirs)
                        dohDirty                     = True

                    break # Done!

                except subprocess.CalledProcessError as error:
                    numberOfIncludeDirs = len(extraIncludeDirs)

                    for line in error.output.split('\n'):
                        match = hFilePat.search(line)

                        if not match:
                            continue

                        try:
                            hFile    = match.group(1)
                            hDirList = fileToDirectories[hFile]
                        except KeyError:
                            print "Looking for " + hFile
                            hDirList = findFile(os.path.dirname(dirPath), hFile, exclude=dirPath)

                        if not hDirList:
                            sys.stderr.write(error.output)
                            sys.exit("%s: Failed to find C header file %s included by %s/%s" % (__file__, hFile, dirPath, entry))

                        if len(hDirList) > 1:
                            sys.stderr.write(error.output)
                            sys.exit("%s: Found C header file %s included by %s/%s in multiple directories: %s"
                                    % (__file__, hFile, dirPath, entry, hDirList))

                        extraIncludeDirs.add(hDirList[0].getRelpath())

                    # If at least on additional directory was added, try again
                    if len(extraIncludeDirs) > numberOfIncludeDirs:
                        continue

                    sys.stderr.write(error.output)
                    sys.exit("%s: Failed to compile C file with: %s" % (__file__, " ".join(ccCommand)))

    if dohDirty:
        with open(dohFile, "w") as output:
            json.dump(directoryToDoh[dirPath], output, sort_keys=True, indent=4, separators=(',', ': '))
            output.write("\n")

    os.chdir(oldPath)

def getSymbolsFromObjectFile(objectFileName):
    symbols = {}

    try:
        for line in subprocess.check_output(["nm", "-gp", "--defined-only", objectFileName], stderr=subprocess.STDOUT).split('\n'):
            match = symbolPat.match(line)

            if match:
                symbols[match.group(1)] = objectFileName

        return symbols

    except subprocess.CalledProcessError as error:
        sys.stderr.write(error.output)
        sys.exit("%s: Unable to get symbol names from %s (in directory %s)" % (__file__, objectFileName, os.getcwd()))

def linkOrArchiveObjects(dirPath):
    """
    Compile all object files created in dirPath and any of its subdirectories
    """

    dohDirty = False
    dohFile  = os.path.join(dirPath, "baker.doh")
    dirDoh   = directoryToDoh[dirPath]
    oldPath  = os.getcwd()

    try:
        os.chdir(dirPath)
        (files, subDirs) = Directory.fromPath(dirPath).getContents()
        print "Linking or archiving directory " + dirPath + " files " + str(files) + " subDirs " + str(subDirs)

        for subDir in subDirs:
            if subDir == ".git":
                continue

            linkOrArchiveObjects(os.path.join(dirPath, subDir))

        objectFiles     = []
        programs        = []
        dirSymbolToFile = {}

        for entry in files:
            if entry.endswith(".c"):
                objectFile   = sourceToTargetFileName(entry)
                symbolToFile = getSymbolsFromObjectFile(objectFile)
                objectFiles.append(objectFile)

                if "main" in symbolToFile:
                    programs.append(entry[:-2])
                else:
                    dirSymbolToFile.update(symbolToFile)

        # If directory does not contain any programs, archive the objects
        if len(programs) == 0:
            if len(dirSymbolToFile) == 0:
                print str(dirSymbolToFile)
                return None

            libName = "target/%s.a" % os.path.basename(dirPath)

            if os.path.isfile(libName):
                os.remove(libName)

            try:
                arCommand = ["ar", "rc", libName]
                arCommand.extend(objectFiles)
                subprocess.check_output(arCommand)
            except subprocess.CalledProcessError as error:
                sys.stderr.write(error.output)
                sys.exit("%s: Unable to create library %s from %s" % (__file__, objectFileName))

            for symbol in dirSymbolToFile:
                dirSymbolToFile[symbol] = libName

            return dirSymbolToFile

        # Try to build any programs in the directory
        for program in programs:
            print "Linking program: " + program
            pass

    except:
        raise

    finally:
        if dohDirty:
            with open(dohFile, "w") as output:
                json.dump(directoryToDoh[dirPath], output, sort_keys=True, indent=4, separators=(',', ': '))
                output.write("\n")

        os.chdir(oldPath)

# Compile any source files found in and under the current directory, then link any programs and archive any directories with none

dirPath = os.path.abspath(".")
compileSources(dirPath)
linkOrArchiveObjects(dirPath)
