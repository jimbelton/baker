#!/usr/bin/python

"""baker - build C libraries and programs without a makefile

Usage: baker [-nv]

Options:
    -n --noaction  Tell what would be done without actually doing it
    -v --verbose   Tell what is being done
"""

import os
import re
import subprocess
import sys

sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), "lib"))
from baker.doh import Doh

directories       = {}
fileToDirectories = {}
symbolToFiles     = {}
hFilePat          = re.compile(r'\s(\S+\.h): No such file')
symbolPat         = re.compile(r'[\da-f]+\s+\w\s+(\w+)$')

class Directory:
    def __init__(self, path):
        self.path         = path
        directories[path] = self

    @classmethod
    def fromPath(clazz, path):
        """
        Get or construct directory object for path
        """

        try:
            return directories[path]
        except KeyError:
            return clazz(path)

    def getRelpath(self, start=os.curdir):
        return os.path.relpath(self.path, start)

    def getContents(self):
        """
        Get contents of directory, caching them, and map include/import file names back to directories
        @return an ordered pair of lists of files and subdirectories
        """

        #print "getContents " + self.path
        try:
            return (self.files, self.subDirs)
        except AttributeError:
            self.files   = []
            self.subDirs = []

            for entry in os.listdir(self.path):
                entryPath = os.path.join(self.path, entry)
                #print entryPath
                if os.path.isdir(entryPath):
                    self.subDirs.append(entry)
                    continue

                if os.path.isfile(entryPath):
                    self.files.append(entry)

                    # Map files that we may need to search for (e.g. header files)

                    if entry.endswith(".h"):
                        if entry not in fileToDirectories:
                            fileToDirectories[entry] = [self]
                        else:
                            fileToDirectories[entry].append(self)

        return (self.files, self.subDirs)

def findFile(dirPath, fileName, exclude=None):
    """
    Look for the fileName in all directories under the dirPath, excluding the exclude subdirectory if set or parent if ".."
    """

    (files, subDirs) = Directory.fromPath(dirPath).getContents()
    #print "Looking for %s under %s (subDirs=%s)" % (fileName, dirPath, str(subDirs))

    # May be in this directory
    try:
        return fileToDirectories[fileName]
    except KeyError:
        pass

    # Otherwise, look in all subdirectories

    for subDir in subDirs:
        if subDir == exclude or subDir == ".git":
            continue

        findFile(os.path.join(dirPath, subDir), fileName, exclude="..")

    # Return if found
    try:
        return fileToDirectories[fileName]
    except KeyError:
        pass

    # If we came from the parent, return none
    if exclude == "..":
        return None

    parent = os.path.dirname(dirPath)

    # Don't leave the user's directory; may want to allow this to be overridden
    if parent == "/home":
        return None

    return findFile(parent, fileName, exclude=dirPath)

def sourceToTargetFileName(sourceFileName):
    return "target/" + sourceFileName[:-2] + ".o"

def compileSources(dirPath):
    """
    Compile all source files found in dirPath and any of its subdirectories
    """
    dirDoh  = Doh.fromDirPath(dirPath)
    oldPath = os.getcwd()
    os.chdir(dirPath)
    (files, subDirs) = Directory.fromPath(dirPath).getContents()
    print "Compiling directory " + dirPath + " files " + str(files) + " subDirs " + str(subDirs)

    for subDir in subDirs:
        if subDir == ".git":
            continue

        compileSources(os.path.join(dirPath, subDir))

    for entry in files:
        if entry.endswith(".c"):
            if not os.path.isdir("target"):
                os.mkdir("target")

            entryIncludeDirsProp = entry + ".includeDirectories"
            extraIncludeDirs     = set(dirDoh.getProperty(entryIncludeDirsProp, default=[]))

            while True:
                try:
                    ccCommand = ["cc", "-c", os.path.join(dirPath, entry), "-o", sourceToTargetFileName(entry)]

                    for incDirPath in list(extraIncludeDirs):
                        ccCommand.extend(["-I", incDirPath])

                    print "about to " + " ".join(ccCommand)
                    subprocess.check_output(ccCommand, stderr=subprocess.STDOUT)

                    if len(extraIncludeDirs) > len(dirDoh.getProperty(entryIncludeDirsProp, default=[])):
                        dirDoh.setProperty(entryIncludeDirsProp, list(extraIncludeDirs))

                    break # Done!

                except subprocess.CalledProcessError as error:
                    numberOfIncludeDirs = len(extraIncludeDirs)

                    for line in error.output.split('\n'):
                        match = hFilePat.search(line)

                        if not match:
                            continue

                        try:
                            hFile    = match.group(1)
                            hDirList = fileToDirectories[hFile]
                        except KeyError:
                            print "Looking for " + hFile
                            hDirList = findFile(os.path.dirname(dirPath), hFile, exclude=dirPath)

                        if not hDirList:
                            sys.stderr.write(error.output)
                            sys.exit("%s: Failed to find C header file %s included by %s/%s" % (__file__, hFile, dirPath, entry))

                        if len(hDirList) > 1:
                            sys.stderr.write(error.output)
                            sys.exit("%s: Found C header file %s included by %s/%s in multiple directories: %s"
                                    % (__file__, hFile, dirPath, entry, hDirList))

                        extraIncludeDirs.add(hDirList[0].getRelpath())

                    # If at least on additional directory was added, try again
                    if len(extraIncludeDirs) > numberOfIncludeDirs:
                        continue

                    sys.stderr.write(error.output)
                    sys.exit("%s: Failed to compile C file with: %s" % (__file__, " ".join(ccCommand)))

    dirDoh.flushIfDirty()
    os.chdir(oldPath)

def getSymbolsFromObjectFile(objectFileName):
    symbols = set()

    try:
        for line in subprocess.check_output(["nm", "-gp", "--defined-only", objectFileName], stderr=subprocess.STDOUT).split('\n'):
            match = symbolPat.match(line)

            if match:
                symbols.add(match.group(1))

        return symbols

    except subprocess.CalledProcessError as error:
        sys.stderr.write(error.output)
        sys.exit("%s: Unable to get symbol names from %s (in directory %s)" % (__file__, objectFileName, os.getcwd()))

def dictOfListsBulkAdd(intoDict, keySet, value):
    for key in keySet:
        if key in intoDict:
            intoDict[key].add(value)
        else:
            intoDict[key] = [value]

def dictOfListsExtend(intoDict, fromDict):
    for key in fromDict:
        if key in intoDict:
            intoDict[key].extend(fromDict[key])
        else:
            intoDict[key] = fromDict[key]

undefSymbolPat = re.compile(r': undefined reference to [\'`](\w+)\'')

def archiveObjects(dirPath):
    """
    Archive all object files in dirPath and any of its subdirectories that do not contain programs
    """
    dirDoh  = Doh.fromDirPath(dirPath)
    oldPath  = os.getcwd()

    try:
        os.chdir(dirPath)
        (files, subDirs) = Directory.fromPath(dirPath).getContents()
        print "Linking or archiving directory " + dirPath + " files " + str(files) + " subDirs " + str(subDirs)

        for subDir in subDirs:
            if subDir == ".git":
                continue

            archiveObjects(os.path.join(dirPath, subDir))

        objectFiles      = []
        programs         = []
        dirSymbolToFiles = {}

        for entry in files:
            if entry.endswith(".c"):
                objectFile = sourceToTargetFileName(entry)
                symbols    = getSymbolsFromObjectFile(objectFile)

                if "main" in symbols:
                    programs.append(entry[:-2])
                else:
                    objectFiles.append(objectFile)
                    dictOfListsBulkAdd(dirSymbolToFiles, symbols, objectFile)

        # If any new programs were found, update the doh
        if len(programs) > len(dirDoh.getProperty("programs", [])):
            dirDoh.setProperty("programs", programs)

        archive = dirDoh.getProperty("archive")

        # If any progam was found and no explicit doh telling baker to make an archive, return
        if len(programs) > 0 and not archive:
            return

        if len(dirSymbolToFiles) == 0:
            return

        if not archive:
            archive = "target/%s.a" % os.path.basename(dirPath)
            dirDoh.setProperty("archive", archive)

        if os.path.isfile(archive):
            os.remove(archive)

        try:
            arCommand = ["ar", "rc", archive]
            arCommand.extend(objectFiles)
            subprocess.check_output(arCommand)
        except subprocess.CalledProcessError as error:
            sys.stderr.write(error.output)
            sys.exit("%s: Unable to create library %s from %s" % (__file__, objectFileName))

        for symbol in dirSymbolToFiles:
            if len(dirSymbolToFiles[symbol]) == 1:
                dirSymbolToFiles[symbol] = [archive]

        dictOfListsExtend(symbolToFiles, dirSymbolToFiles)

    except:
        raise

    finally:
        dirDoh.flushIfDirty()
        os.chdir(oldPath)

def linkPrograms(dirPath):
    """
    Link all programs in dirPath and any of its subdirectories
    """
    dirDoh  = Doh.fromDirPath(dirPath)
    oldPath  = os.getcwd()

    try:
        os.chdir(dirPath)
        (files, subDirs) = Directory.fromPath(dirPath).getContents()
        print "Linking or archiving directory " + dirPath + " files " + str(files) + " subDirs " + str(subDirs)

        for subDir in subDirs:
            if subDir == ".git":
                continue

            linkOrArchiveObjects(os.path.join(dirPath, subDir))

        objectFiles      = []
        programs         = []
        dirSymbolToFiles = {}

        for entry in files:
            if entry.endswith(".c"):
                objectFile = sourceToTargetFileName(entry)
                symbols    = getSymbolsFromObjectFile(objectFile)
                objectFiles.append(objectFile)

                if "main" in symbols:
                    programs.append(entry[:-2])
                else:
                    dictOfListsBulkAdd(dirSymbolToFiles, symbols, objectFile)

        # If directory does not contain any programs, archive the objects
        if len(programs) == 0:
            if len(dirSymbolToFiles) == 0:
                return None

            libName = "target/%s.a" % os.path.basename(dirPath)

            if os.path.isfile(libName):
                os.remove(libName)

            try:
                arCommand = ["ar", "rc", libName]
                arCommand.extend(objectFiles)
                subprocess.check_output(arCommand)
            except subprocess.CalledProcessError as error:
                sys.stderr.write(error.output)
                sys.exit("%s: Unable to create library %s from %s" % (__file__, objectFileName))

            for symbol in dirSymbolToFile:
                if len(dirSymbolToFiles[symbol]) == 1:
                    dirSymbolToFiles[symbol] = [libName]

            return dirSymbolToFiles

        # Try to build any programs in the directory
        for program in programs:
            print "Linking program: " + program

            while True:
                try:
                    ldCommand = ["cc", sourceToTargetFileName(program + ".c"), "-o", "target/" + program]

                    #for incDirPath in list(extraIncludeDirs):
                    #    ccCommand.extend(["-I", incDirPath])

                    print "about to " + " ".join(ldCommand)
                    subprocess.check_output(ldCommand, stderr=subprocess.STDOUT)

                    #if len(extraIncludeDirs) > (len(dirDoh[entryIncludeDirsProp]) if entryIncludeDirsProp in dirDoh else 0):
                    #    dirDoh[entryIncludeDirsProp] = list(extraIncludeDirs)
                    #    dohDirty                     = True

                    break # Done!

                except subprocess.CalledProcessError as error:
                    #numberOfIncludeDirs = len(extraIncludeDirs)

                    for line in error.output.split('\n'):
                        match = undefSymbolPat.search(line)

                        if not match:
                            continue

                        #print match.group(1)

                        try:
                            symbol   = match.group(1)
                            fileList = dirSymbolToFiles[symbol]
                        except KeyError:
                            print "Failed to find symbol " + symbol
                    #        hDirList = findFile(os.path.dirname(dirPath), hFile, exclude=dirPath)
                    #
                    #    if not hDirList:
                    #        sys.stderr.write(error.output)
                    #        sys.exit("%s: Failed to find C header file %s included by %s/%s" % (__file__, hFile, dirPath, entry))
                    #
                    #    if len(hDirList) > 1:
                    #        sys.stderr.write(error.output)
                    #        sys.exit("%s: Found C header file %s included by %s/%s in multiple directories: %s"
                    #                % (__file__, hFile, dirPath, entry, hDirList))
                    #
                    #    extraIncludeDirs.add(hDirList[0].getRelpath())
                    #
                    ## If at least on additional directory was added, try again
                    #if len(extraIncludeDirs) > numberOfIncludeDirs:
                    #    continue

                    sys.stderr.write(error.output)
                    sys.exit("%s: Failed to link C program with: %s" % (__file__, " ".join(ldCommand)))

    except:
        raise

    finally:
        dirDoh.flushIfDirty()
        os.chdir(oldPath)

# Compile any source files found in and under the current directory, then link any programs and archive any directories with none

dirPath = os.path.abspath(".")
compileSources(dirPath)
archiveObjects(dirPath)
#linkPrograms(dirPath)
