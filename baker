#!/usr/bin/python

import json
import os
import re
import subprocess
import sys

directoryToDoh    = {}
directories       = {}
fileToDirectories = {}
hFilePat          = re.compile(r'\s(\S+\.h): No such file')

class Directory:
    def __init__(self, path):
        self.path         = path
        directories[path] = self

    @classmethod
    def fromPath(clazz, path):
        """
        Get or construct directory object for path
        """

        try:
            return directories[path]
        except KeyError:
            return clazz(path)

    def getRelpath(self, start=os.curdir):
        return os.path.relpath(self.path, start)

    def getContents(self):
        """
        Get contents of directory, caching them, and map include/import file names back to directories
        @return an ordered pair of lists of files and subdirectories
        """

        #print "getContents " + self.path
        try:
            return (self.files, self.subDirs)
        except AttributeError:
            self.files   = []
            self.subDirs = []

            for entry in os.listdir(self.path):
                entryPath = os.path.join(self.path, entry)
                #print entryPath
                if os.path.isdir(entryPath):
                    self.subDirs.append(entry)
                    continue

                if os.path.isfile(entryPath):
                    self.files.append(entry)

                    # Map files that we may need to search for (e.g. header files)

                    if entry.endswith(".h"):
                        if entry not in fileToDirectories:
                            fileToDirectories[entry] = [self]
                        else:
                            fileToDirectories[entry].append(self)

        return (self.files, self.subDirs)

def findFile(dirPath, fileName, exclude=None):
    """
    Look for the fileName in all directories under the dirPath, excluding the exclude subdirectory if set or parent if ".."
    """

    (files, subDirs) = Directory.fromPath(dirPath).getContents()
    #print "Looking for %s under %s (subDirs=%s)" % (fileName, dirPath, str(subDirs))

    # May be in this directory
    try:
        return fileToDirectories[fileName]
    except KeyError:
        pass

    # Otherwise, look in all subdirectories

    for subDir in subDirs:
        if subDir == exclude or subDir == ".git":
            continue

        findFile(os.path.join(dirPath, subDir), fileName, exclude="..")

    # Return if found
    try:
        return fileToDirectories[fileName]
    except KeyError:
        pass

    # If we came from the parent, return none
    if exclude == "..":
        return None

    parent = os.path.dirname(dirPath)

    # Don't leave the user's directory; may want to allow this to be overridden
    if parent == "/home":
        return None

    return findFile(parent, fileName, exclude=dirPath)

def compileDir(dirPath):
    """
    Compile all source files found in dirPath and any of its subdirectories
    """

    dohDirty = False
    dohFile  = os.path.join(dirPath, "baker.doh")

    if dirPath not in directoryToDoh:
        print dohFile
        if os.path.isfile(dohFile):
            with open(dohFile) as input:
                contents = input.read()

                try:
                    directoryToDoh[dirPath] = json.loads(contents)
                except ValueError:
                    sys.exit("%s: Can't understand contents of %s:\n'%s'" % (__file__, dohFile, contents))

        else:
            directoryToDoh[dirPath] = {}

    dirDoh  = directoryToDoh[dirPath]
    oldPath = os.getcwd()
    os.chdir(dirPath)
    (files, subDirs) = Directory.fromPath(dirPath).getContents()
    print "Compiling directory " + dirPath + " files " + str(files) + " subDirs " + str(subDirs)

    for subDir in subDirs:
        if subDir == ".git":
            continue

        compileDir(os.path.join(dirPath, subDir))

    for entry in files:
        if entry.endswith(".c"):
            if not os.path.isdir("target"):
                os.mkdir("target")

            entryIncludeDirsProp = entry + ".includeDirectories"
            extraIncludeDirs     = set(dirDoh[entryIncludeDirsProp] if entryIncludeDirsProp in dirDoh else [])

            while True:
                try:
                    ccCommand = ["cc", "-c", os.path.join(dirPath, entry), "-o", "target/" + entry[:-2] + ".o"]

                    for incDirPath in list(extraIncludeDirs):
                        ccCommand.extend(["-I", incDirPath])

                    print "about to " + " ".join(ccCommand)
                    subprocess.check_output(ccCommand, stderr=subprocess.STDOUT)

                    if len(extraIncludeDirs) > (len(dirDoh[entryIncludeDirsProp]) if entryIncludeDirsProp in dirDoh else 0):
                        dirDoh[entryIncludeDirsProp] = list(extraIncludeDirs)
                        dohDirty                     = True

                    break # Done!

                except subprocess.CalledProcessError as error:
                    numberOfIncludeDirs = len(extraIncludeDirs)

                    for line in error.output.split('\n'):
                        match = hFilePat.search(line)

                        if not match:
                            continue

                        try:
                            hFile    = match.group(1)
                            hDirList = fileToDirectories[hFile]
                        except KeyError:
                            print "Looking for " + hFile
                            hDirList = findFile(os.path.dirname(dirPath), hFile, exclude=dirPath)

                        if not hDirList:
                            sys.stderr.write(error.output)
                            sys.exit("%s: Failed to find C header file %s included by %s/%s" % (__file__, hFile, dirPath, entry))

                        if len(hDirList) > 1:
                            sys.stderr.write(error.output)
                            sys.exit("%s: Found C header file %s included by %s/%s in multiple directories: %s"
                                    % (__file__, hFile, dirPath, entry, hDirList))

                        extraIncludeDirs.add(hDirList[0].getRelpath())

                    # If at least on additional directory was added, try again
                    if len(extraIncludeDirs) > numberOfIncludeDirs:
                        continue

                    sys.stderr.write(error.output)
                    sys.exit("%s: Failed to compile C file with: %s" % (__file__, " ".join(ccCommand)))

    if dohDirty:
        with open(dohFile, "w") as output:
            json.dump(directoryToDoh[dirPath], output, sort_keys=True, indent=4, separators=(',', ': '))
            output.write("\n")

    os.chdir(oldPath)

# Compile any source files found in and under the current directory

dirPath = os.path.abspath(".")
compileDir(dirPath)
