#!/usr/bin/python

"""baker - build C libraries and programs without a makefile

Usage: baker [-ntv]

Options:
    -n --noaction  Tell what would be done without actually doing it
    -t --test      Run any test programs found
    -v --verbose   Tell what is being done
"""

import os
import re
import resource
import signal
import subprocess
import sys

sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), "lib"))
from baker.doh  import Doh
from directory  import Directory, fileToDirectories
from docopt     import docopt
from options    import error, fatal, getOption, setOptions, takeAction
from OrderedSet import OrderedSet

setOptions(docopt(__doc__, version='1.0'))

startDirPath   = os.path.abspath(".")
symbolToFiles  = {}
hFilePat       = re.compile(r'\s(\S+\.h): No such file')
symbolPat      = re.compile(r'[\da-f]+\s+\w\s+(\w+)$')
testPat        = re.compile(r'test')

def findFile(dirPath, fileName, exclude=None):
    """
    Look for the fileName in all directories under the dirPath, excluding the exclude subdirectory if set or parent if ".."
    """

    (files, subDirs) = Directory.fromPath(dirPath).getContents()
    #print "Looking for %s under %s (subDirs=%s, files=%s)" % (fileName, dirPath, str(subDirs), str(files))

    # Look in all subdirectories

    for subDir in subDirs:
        if subDir == exclude:
            continue

        findFile(os.path.join(dirPath, subDir), fileName, exclude="..")

    # Return if found
    directories = fileToDirectories.get(fileName)

    if directories:
        return directories

    # If we came from the parent, return none
    if exclude == "..":
        return None

    parent = os.path.dirname(dirPath)

    # Don't leave the user's directory; may want to allow this to be overridden
    if parent == "/home":
        return None

    return findFile(parent, fileName, exclude=os.path.basename(dirPath))

def sourceToTargetFileName(sourceFileName):
    return "target/" + sourceFileName[:-2] + ".o"

def compileSources(dirPath):
    """
    Compile all source files found in dirPath and any of its subdirectories
    """
    dirDoh                  = Doh.fromDirPath(dirPath)
    preferredIncludeDirExps = dirDoh.getProperty("preferredIncludeDirExps")
    oldPath                 = os.getcwd()
    os.chdir(dirPath)
    (files, subDirs) = Directory.fromPath(dirPath).getContents()
    #print "Compiling directory " + dirPath + " files " + str(files) + " subDirs " + str(subDirs)

    for subDir in subDirs:
        compileSources(os.path.join(dirPath, subDir))

    for entry in files:
        if entry.endswith(".c"):
            if not os.path.isdir("target"):
                os.mkdir("target")

            entryIncludeDirsProp = entry + ".includeDirectories"
            extraIncludeDirs     = set(dirDoh.getProperty(entryIncludeDirsProp, default=[]))
            lenExtraIncludeDirs  = len(extraIncludeDirs)

            while True:
                try:
                    ccCommand = ["cc", "-O3", "-c", os.path.join(dirPath, entry), "-o", sourceToTargetFileName(entry)]

                    for incDirPath in list(extraIncludeDirs):
                        ccCommand.extend(["-I", incDirPath])

                    if takeAction(" ".join(ccCommand)):
                        subprocess.check_output(ccCommand, stderr=subprocess.STDOUT)

                    # If the include path has grown, update the doh
                    #
                    if len(extraIncludeDirs) > lenExtraIncludeDirs:
                        dirDoh.setProperty(entryIncludeDirsProp, list(extraIncludeDirs))

                    break # Done!

                except subprocess.CalledProcessError as exception:
                    numberOfIncludeDirs = len(extraIncludeDirs)

                    for line in exception.output.split('\n'):
                        match = hFilePat.search(line)

                        if not match:
                            continue

                        hFile    = match.group(1)
                        hDirList = fileToDirectories.get(hFile)

                        # May be in the cache
                        if not hDirList:
                            hDirList = fileToDirectories.get(hFile)

                        if not hDirList:
                            hDirList = findFile(os.path.dirname(dirPath), hFile, exclude=os.path.basename(dirPath))

                        if not hDirList:
                            sys.stderr.write(exception.output)
                            fatal("Failed to find C header file %s included by %s/%s" % (hFile, dirPath, entry))

                        if len(hDirList) > 1:
                            if (preferredIncludeDirExps):
                                print str(preferredIncludeDirExps)
                                for hDir in hDirList:
                                    for exp in preferredIncludeDirExps:
                                        if re.match(exp, hDir.path):
                                            hDirList = [hDir]
                                            break

                                    if len(hDirList) == 1:
                                        break

                            if len(hDirList) > 1:
                                sys.stderr.write(exception.output)
                                fatal("Found C header file %s included by %s/%s exists in multiple directories: %s"
                                        % (hFile, dirPath, entry, [hDir.path for hDir in hDirList]))

                        extraIncludeDirs.add(hDirList[0].getRelpath())

                    # If at least on additional directory was added, try again
                    if len(extraIncludeDirs) > numberOfIncludeDirs:
                        continue

                    sys.stderr.write(exception.output)
                    fatal("Failed to compile C file with: %s" % (" ".join(ccCommand)))

    dirDoh.flushIfDirty()
    os.chdir(oldPath)

def getSymbolsFromObjectFile(objectFileName):
    symbols = set()

    try:
        for line in subprocess.check_output(["nm", "-gp", "--defined-only", objectFileName], stderr=subprocess.STDOUT).split('\n'):
            match = symbolPat.match(line)

            if match:
                symbols.add(match.group(1))

        return symbols

    except subprocess.CalledProcessError as exception:
        sys.stderr.write(exception.output)
        fatal("Unable to get symbol names from %s (in directory %s)" % (objectFileName, os.getcwd()))

def dictOfListsBulkAdd(intoDict, keySet, value):
    for key in keySet:
        if key in intoDict:
            intoDict[key].append(value)
        else:
            intoDict[key] = [value]

def dictOfListsExtend(intoDict, fromDict):
    for key in fromDict:
        if key in intoDict:
            intoDict[key].extend(fromDict[key])
        else:
            intoDict[key] = fromDict[key]

undefSymbolPat = re.compile(r': undefined reference to [\'`](\w+)\'')

def archiveObjects(dirPath):
    """
    Archive all object files in dirPath and any of its subdirectories that do not contain programs
    """
    dirDoh  = Doh.fromDirPath(dirPath)
    oldPath  = os.getcwd()

    try:
        os.chdir(dirPath)
        directory        = Directory.fromPath(dirPath)
        (files, subDirs) = directory.getContents()
        #print "Archiving directory " + dirPath + " files " + str(files) + " subDirs " + str(subDirs)

        for subDir in subDirs:
            archiveObjects(os.path.join(dirPath, subDir))

        objectFiles      = []
        programs         = []
        dirSymbolToFiles = {}

        for entry in files:
            if entry.endswith(".c"):
                objectFile = sourceToTargetFileName(entry)
                symbols    = getSymbolsFromObjectFile(objectFile)

                if "main" in symbols:
                    programs.append(entry[:-2])
                else:
                    objectFiles.append(objectFile)
                    dictOfListsBulkAdd(dirSymbolToFiles, symbols, objectFile)

        # If any new programs were found, update the doh
        if len(programs) > len(dirDoh.getProperty("programs", [])):
            dirDoh.setProperty("programs", programs)

        archive = dirDoh.getProperty("archive")

        # If any progam was found and no explicit doh telling baker to make an archive, return
        if len(programs) > 0 and not archive:
            directory.symbolToFiles = dirSymbolToFiles
            return

        if len(dirSymbolToFiles) == 0:
            return

        if not archive:
            archive = "target/%s.a" % os.path.basename(dirPath)
            dirDoh.setProperty("archive", archive)

        if os.path.isfile(archive):
            os.remove(archive)

        try:
            arCommand = ["ar", "rc", archive]
            arCommand.extend(objectFiles)

            if takeAction(" ".join(arCommand)):
                subprocess.check_output(arCommand)
        except subprocess.CalledProcessError as exception:
            sys.stderr.write(exception.output)
            fatal("Unable to create library %s from %s" % (objectFileName))

        for symbol in dirSymbolToFiles:
            if len(dirSymbolToFiles[symbol]) == 1:
                dirSymbolToFiles[symbol] = [os.path.join(dirPath, archive)]

        dictOfListsExtend(symbolToFiles, dirSymbolToFiles)

    except:
        raise

    finally:
        dirDoh.flushIfDirty()
        os.chdir(oldPath)

def findSymbol(dirPath, symbol, exclude=None):
    """
    Look for the symbols in all directories under the dirPath, excluding the exclude subdirectory if set or parent if ".."
    """

    directory = Directory.fromPath(dirPath)

    try:
        if directory.symbolsIndexed:
            return None
    except AttributeError:
        pass

    (files, subDirs) = Directory.fromPath(dirPath).getContents()
    #print "Looking for %s under %s (subDirs=%s)" % (symbol, dirPath, str(subDirs))

    # Look in all subdirectories

    for subDir in subDirs:
        if subDir == exclude:
            continue

        findSymbol(os.path.join(dirPath, subDir), symbol, exclude="..")

    # If there are any libraries in the current directory, map them

    for file in files:
        if file.endswith(".a"):
            filePath = os.path.join(dirPath, file)
            symbols  = getSymbolsFromObjectFile(filePath)
            dictOfListsBulkAdd(symbolToFiles, symbols, filePath)

    directory.symbolsIndexed = True

    # Return if found

    foundFiles = symbolToFiles.get(symbol)

    if foundFiles:
        return foundFiles

    # If we came from the parent, return none
    if exclude == "..":
        return None

    parent = os.path.dirname(dirPath)

    # Don't leave the user's directory; may want to allow this to be overridden
    if parent == "/home":
        return None

    return findSymbol(parent, symbol, exclude=os.path.basename(dirPath))

def enableCoreDumps():
    resource.setrlimit(resource.RLIMIT_CORE, (resource.RLIM_INFINITY, resource.RLIM_INFINITY))

def linkPrograms(dirPath):
    """
    Link all programs in dirPath and any of its subdirectories
    """
    dirDoh              = Doh.fromDirPath(dirPath)
    preferredLibrarySet = dirDoh.getProperty("preferredLibraries") if dirDoh.getProperty("preferredLibraries") else None
    oldPath             = os.getcwd()

    try:
        os.chdir(dirPath)
        directory        = Directory.fromPath(dirPath)
        (files, subDirs) = directory.getContents()
        programs         = dirDoh.getProperty("programs", [])
        #print "Linking programs in directory " + dirPath + " files " + str(files) + " subDirs " + str(subDirs)

        for subDir in subDirs:
            linkPrograms(os.path.join(dirPath, subDir))

        # Try to build any programs in the directory
        for program in programs:
            #print "Linking program: " + program
            programObjectFilesProp = program + ".objectFiles"
            extraObjectFiles       = OrderedSet(dirDoh.getProperty(programObjectFilesProp, []))
            lenExtraObjectFiles    = len(extraObjectFiles)

            while True:
                try:
                    ldCommand = ["cc", sourceToTargetFileName(program + ".c"), "-o", "target/" + program]

                    for objectFile in extraObjectFiles.toList():
                        ldCommand.append(objectFile)

                    if takeAction(" ".join(ldCommand)):
                        subprocess.check_output(ldCommand, stderr=subprocess.STDOUT)

                    # If the number of object files has grown, update the doh
                    #
                    if len(extraObjectFiles) > lenExtraObjectFiles:
                        dirDoh.setProperty(programObjectFilesProp, extraObjectFiles.toList())

                    break # Done!

                except subprocess.CalledProcessError as exception:
                    numberOfObjectFiles = len(extraObjectFiles)
                    undefinedSymbols    = []

                    for line in exception.output.split('\n'):
                        match = undefSymbolPat.search(line)

                        if not match:
                            continue

                        undefinedSymbols.append(match.group(1))

                    for symbol in undefinedSymbols:
                        # First, look in any object files in the same directory
                        oFileList = directory.symbolToFiles.get(symbol)

                        # May be in the cache
                        if not oFileList:
                            oFileList = symbolToFiles.get(symbol)

                        # Look in higher level directories for archives
                        if not oFileList:
                            oFileList = findSymbol(os.path.dirname(startDirPath), symbol, exclude=os.path.basename(startDirPath))

                        if not oFileList:
                            sys.stderr.write(exception.output)
                            fatal("Failed to find symbol %s needed by %s in %s" % (hFile, program, dirPath))

                        if len(oFileList) > 1:
                            if (preferredLibrarySet):
                                for oFile in oFileList:
                                    if os.path.basename(oFile) in preferredLibrarySet:
                                        oFileList = [oFile]
                                        break

                            if len(oFileList) > 1:
                                sys.stderr.write(exception.output)
                                fatal("Found symbol %s needed by %s in %s in multiple files: %s"
                                      % (symbol, program, dirPath, oFileList))

                        extraObjectFiles.add(os.path.relpath(oFileList[0]))

                    # If no additional object files were added, fail
                    if len(extraObjectFiles) <= numberOfObjectFiles:
                        sys.stderr.write(exception.output)
                        fatal("Failed to link C program with: %s" % (" ".join(ldCommand)))

            if getOption("test") and testPat.match(program) and takeAction("run " + program):
                try:
                    output = subprocess.check_output(["target/" + program], stderr=subprocess.STDOUT, preexec_fn=enableCoreDumps)

                    if getOption("verbose"):
                        sys.stdout.write(output)
                except subprocess.CalledProcessError as exception:
                    sys.stderr.write(exception.output)

                    if exception.returncode == -signal.SIGSEGV:
                        fatal("Test program %s was killed with a segmentation fault" % program)

                    error("Test failure in program " + program)

    except:
        raise

    finally:
        dirDoh.flushIfDirty()
        os.chdir(oldPath)

# Compile any source files found in and under the current directory, then link any programs and archive any directories with none

Directory.setIndexExp(r'.+\.h$')
compileSources(startDirPath)
archiveObjects(startDirPath)
linkPrograms(startDirPath)
